
# 第7回

タイプ: メモ
作成日: Jun 15, 2020 1:05 PM
復習済み: No
講義名: ネットワークプログラミング

次週と合わせて一回分

# select

入力データがあるかどうか？　←今回はこれをSelectで判断する

出力データが用意できているかどうか？

recv()したのに、まだデータが届いていなかった

この時、プログラムがストップしてしまい、相手が結局送信してこなかったら、それまで待つのは無駄すぎる

selectを使えば、データが届いていることを確認してから、recv()を実行する、ということができるようになる

ディスクリプタの範囲を指定する必要があるが、これをbitmaskで指定する

これで、監視する範囲を指定することができるようになる

ビットのn番目はディスクリプタのn番目に対応していて、

- 0番目は、標準入力stdout
- 1番目は、標準エラー出力stderrかも？

0番と、sock番号（サーバーの部分に対応する？）にマスクをセットすることになる

selectの呼び出しで、maskが変化してしまう

出力を入力に使ったmaskに対して行うということ？ポインタ渡しているので、やっぱりそうらしい。

なので、一旦別の変数にコピーしてる

今一番大きい番号、maskのbitは、sockの番号なので、そこまで検査するようにしておく

使っていない引数があるが、

3つ目は出力が出来るかどうかを判断するところ、

4つ目は例外が生じているかを処理する場合、

5つ目タイムアウト、selectっていうのは、ここが変化があるまで監視を続けるっていう処理をするけど、ある程度変化が無かったら、返すみたいな、タイムアウトの処理をしたいときに使用する

今回は、selectから返事があると、何か入力があったということになるので、

FD_ISSETを用いて、どこに実際に入力があったのかというのをしることができる

0番は、キーボードから入力があったかどうかを判断できる

一つ目、条件が真になっていれば、キーボードからの入力があったということなので、fgetすれば、すぐに文字列を取得することが出来る

次に、sockのFD_ISSETが真になるなら、サーバーから文字列を受信しているということなので、recv()すればOK

fflushで強制的に表示するようにしている

Send、Recvは、別ソースコードに本体が用意されている

なんで、これいるん？

もともとのsendを覆ってSendを作る、これをラッパーというが、

メインの処理では、エラー処理を隠蔽しているが、実際はエラー処理している

メイン関数でエラー処理が書かれていないので、流れが分かりやすい

エラー処理に関しては、一カ所で書くことが出来ていい

ラッパーを作って分かりやすくすることが多いです
