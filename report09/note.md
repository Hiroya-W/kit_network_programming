
# 第9回

タイプ: ノート
作成日: Jun 29, 2020 1:03 PM
復習済み: No
講義名: ネットワークプログラミング

TCPは信頼性のある通信だった

途中でパケットが送れなかった場合も、再送してくれた

到着順の調整やフロー制御など、信頼性を確保していた

そのためには、セッションの確立が必要だったし、終了時にも解放が必要だった

UDPは今回はいらない。

その代わり、信頼性を保証しないので、送ってしまえば後は知らない

大雑把？

というか、そういった処理によるオーバーヘッドがないので軽い

パケットどっかいった！？

という状況でも、プログラムがバグらないように、ちゃんと動くようにしないといけない

TCPはブロードキャストが出来なかった

そもそも、通信するために相手とコネクションを張る必要があった

が、UDPはコネクション貼らないので、接続している相手に全員に送れる

TCPはずーっと通信する場合には、いい。が、UDPは、ちょっとだけ送ってそれっきり、みたいな状況に良い。

音声・動画とか、1コマ送れなかったとしても、まぁリアルタイム性を重視するので

# UDPでクライアントプログラム

## UDPでソケットを作る方法が違う

ソケット使うけど、2つ目の値が違う

SOCK_DGRAMを使う

まぁ、使い方はTCPと同じでしょう

## 送信が違う

データを送信する際に、相手先が必要かが違う

sendtoが、相手先のアドレスが必要になる

そもそも、TCPはソケットを作った時点？で、相手先が決まっているので、アドレスを設定する必要がなかった

UDPは、相手とコネクションはらないので、必要になるよね。

5つ目の引数、sockaddr_in構造体をより一般的な型であるsockaddrにキャストする

これで、server_adrsに指定されたアドレスに送信される

## 受信が違う

送信時と同様に、どこから受信するのか、パケットが届いてみないと分からない

で、それが分かるように、どこから受信するのかっていうのを分かるようにしないと行けない

で、そのパケットがどの相手から届いたものなのか、をfrom_adrに格納して、受信するようになっている

# UDPでサーバプログラム

sockaddr_in構造体を作るのは、TCPと同じ

DGRAMモードでソケットを作るのは、UDPだった

バインドするのは、TCPと同じなので、確認する

文字列を受信した時、送られてきた相手に文字列を返したい

だから、from_adrsに対して、文字列を送信すればいい

## 無限ループ

コネクション張らないので、通信が終了したことが分からない

まだ続きがある？無い？が分からない

で、別のクライアントから受信するかもしらないわけですよね。

でも、そのクライアントに対しても、受信して、送信することができるようになる。

UDPだから。

# UDPをライブラリ化する

mynetに追加する

## show_adrsinfo

送信元アドレスは、バイナリの形で格納されて取得できる

inet_ntoa関数で、192.168.3.11みたいな形に変更できる
